#!/usr/bin/env bash
# uberspace-update_wekan
# This script updates or reverts updates (initiated by this script) to wekan installations hosted on Uberspace 7.
# See https://wekan.github.io for Wekan, and https://uberspace.de/de/ for cli-friendly hosting on Steroids.
# To install wekan on Uberspace 7 hosted domains, if you haven't already, see https://lab.uberspace.de/guide_wekan.html
# v1.0 12.04.2021 created by Kim Diallo/Uberspace.de
# v1.1 13.04.2021 revised by Patrick Raddatz
# v1.3 15.04.2021 improved by Kim Diallo and Patrick Raddatz
# v1.5 03.05.2021 Code completed by Kim Diallo, revised translation by Patrick Raddatz

# Error and var handling (see details at https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html)
set -eauo pipefail

# Declare array with all variables used on runtime, to ease pre-exit cleanup.
declare -a _VARS_=(

	 "_build_dir_"
	 "_dir_"
	 "_former_version_"
	 "_install_dir_"
	 "_node_current_"
	 "_node_version_"
	 "_node_wekan_"
	 "_pid_"
	 "_revert_version_"
	 "_url_"
	 "_usage_"
	)

# Declare all vars
for var in ${_VARS_[@]}; do 		# SC2068 - no quotes expand into multiple other arguments
	declare "${var}"
done

# Store usage message in a var
_usage_="

    update_wekan - an easy way to keep wekan on uberspace up-to-date

    usage:

        update_wekan [options]

    Options:

        --debug							Print various debugging information to stdout.

        --reinstall					Remove folder of current latest wekan if present, and perform a fresh install

        --revert [version]	Roll back to given wekan version, if specified folder exists. If called without specifc version, the penultimate is put back into operation.

        --help							Print this help text and exit.


"


# Print usage
function usage () {

	# Usage only makes sense in a loginshell
	if [ -t ]; then
		printf '\n%s\n' "${_usage_}"
	fi
    }


# Function to grant clean exits all time
function error_exit () {

	# Remove created folders
	rm -rf "${_build_dir_}"
	rm -rf "${_dir_}"

	# Unset used vars
	unset ${_VARS_[@]}           # SC2068 - no quotes expand into multiple other arguments

	# Unset vars array
	unset _VARS_

	# Definitely return error to trigger bash's builtin 'set -e'
	return 1
}


# This function reverts wekan to a prior version
function revert () {

    local _revert_version_="${1}"

    # Check if a given version is present.
    if [ -d "$HOME/wekan/wekan-${_revert_version_}" ]; then

        # Store install dir from destination version to _dir_ var.
        local _dir_="$HOME/wekan/wekan-${_revert_version_}"

        # Store node version to run destination wekan to var.
        local _node_version_="$(cat "${_dir_}"/NODE_VERSION)"

        # Set the needed node version.
        uberspace tools version use node "${_node_version_}"

        # Point the 'current' symlink to given version.
        ln -sfn "${_dir_}/bundle" "$HOME"/wekan/current


        # Check if wekan service is running.
        if restart_wekan; then
            tput smso; echo -e "\n We're done--wekan is operational ${_revert_version_}, exiting now.\n\n"; tput rmso
        else
            tput bel; tput smso; tput setaf 1; echo -e "\n Oops, something went wrong--wekan service isn't running.\n\n"; tput rmso; tput sgr0
            return 1
        fi
    else
        tput bel; tput smso; tput setaf 1; echo -e "\n Install directory to selected wekan version present in $HOME/wekan.\n\n"; tput rmso; tput sgr0
        return 1
    fi

    return 0
    }


# This function monitors the proper supervisorctl sequence (stopping > updating > starting).
function restart_wekan () {

    # Prior check, whether wekan is running at all.
    if $(supervisorctl status wekan |grep -q 'RUNNING'); then

        # If it is, store the PID in local var.
        local _pid_="$(supervisorctl pid wekan)"

        # Now stop wekan.
        supervisorctl stop wekan

        # Wait until we're done.
        while kill -0 "${_pid_}" 2> /dev/null; do
            :
        done

    fi

    # Update and start the wekan service.
    supervisorctl update wekan

    # Wait again, until we're done, avoiding any collisions.
    sleep 1

    # Let's start once more.
    supervisorctl start wekan

    # Set its new PID to a variable.
        local _pid_="$(supervisorctl pid wekan)"

    # Wait once more, just to be safe.
    sleep 10

    # Checking whether wekan service is up & running with the same PID. Return 0 if it is, or 1 if not.
    if $(supervisorctl status wekan |grep -q 'RUNNING'); then

        if [[ "${_pid_}" == "$(supervisorctl pid wekan)" ]]; then
            return 0
        else
            return 1
        fi
    else
        return 1
    fi

    }




# Checking whether wekan service is up & running with the same PID. Return 0 if it is, or 1 if not.
if [[ "${#}" -gt 0 ]]; then


    if [[ "${1}" = "--help" ]]; then
    	usage
    fi


    # Checking whether script was called with '--debug'. If it was, enable verbose stdout and trim the debug arg from $@.
    if [[ "${@}" = *"--debug"* ]]; then
        set -x
        set -- "${@%'--debug'}"
    fi



    # Checking whether script was called with '--revert'. If it was, only revert to a given version and exit.
    if [[ "${@}" == "--revert" ]]; then

        if [[ "${#}" -lt 2 ]]; then
            tput bel; tput smso; tput setaf 1; echo -e "\n Unable to revert, please try: \n\t wekan_update --revert [old version] \n\n"; tput rmso; tput sgr0
            exit 1
        fi

        if revert "${2}"; then
            exit 0
        else
            exit 1
        fi
    fi
fi


# Stores our current wekan version in a variable.
_version_="$(curl --silent https://releases.wekan.team/ |grep -oEm 1 wekan\-[0-9]+\.[0-9]+\.zip)"


# Determines the download URL by means of this variable.
_url_="https://releases.wekan.team/${_version_}"


# Store path to version into variable.
# First create the directory ~/wekan, subsequently a directory
# for said version, and finally the previous path, so we can
# point a symlink to the new version after building it.
_dir_="$HOME/wekan/${_version_/.zip/}"


# Check for currently active node version, store result in a var.
_node_current_="$( node -v|cut -d'v' -f2|cut -d'.' -f1)"

# Acquire the recommended node version from wekan's dockerfile.
_node_wekan_="$(curl --silent https://raw.githubusercontent.com/wekan/wekan/master/Dockerfile |grep -oEm 1 NODE_VERSION=v[0-9]+ |cut -d'v' -f2)" || true

# If a directory, which has been stored in the variable, already exists,
# we can refrain from building wekan and exit the script.
if [[ -d "${_dir_}" ]]; then
    if [[ "${@}" = *"--reinstall"* ]]; then
        rm -rf "${_dir_}"/*
    else
    	tput smso; echo -e "\n Nothing to do, wekan is already up to date, exiting now.\n\n"; tput rmso
    	exit 0
    fi
else
	## Compare both node version. If there is a newer version available, we'll use it.
	## ! Caveat emptor !
	## This is a global change and affects all other software relying on node.
   if [[ "${_node_wekan_}" == "${_node_current_}" ]]; then
	# If the directory doesn't exist yet, let's create it.
    	mkdir -p "${_dir_}"
   else
      tput bel; tput smso; tput setaf 1; echo -e "\nwekan now needs node-v"${_node_wekan_}". If you like, run : \n\n\tuberspace tools version use node "${_node_wekan_}" \n\nand than give this scrpt another try.\n"; tput rmso; tput sgr0

   fi


fi


# Create a download tempdir and store its path into a variable, avoiding
# potential conflicts, and ease our post-build cleanup.
_build_dir_="$(mktemp --directory --tmpdir wekan.XXX)"


# Download and unzip the latest wekan build into our tempdir.
# In order to retain the current user session directory, we're going
# to execute that part in a subshell ( ).
(
    cd "${_build_dir_}"
    wget "${_url_}"
    unzip "${_version_}" -d "${_dir_}"
)

# Remove the obsolete tempdir.
rm -r "${_build_dir_}"

# Let's store the required node version required,
# just in case we need to roll back at some point.
echo "${_node_wekan_}" >> "${_dir_}"/NODE_VERSION

# Store the installation directory in a variable, npm needs to be executed from there.
_install_dir_="${_dir_}/bundle/programs/server"

# Store some files, which would interfere with a rebuild, in an array.
declare -a _FILES_TO_REMOVE_=(

    "${_install_dir_}/node_modules/.bin/node-gyp"
    "${_install_dir_}/node_modules/.bin/node-pre-gyp"
    "${_install_dir_}/node_modules/chalk/node_modules/.bin/strip-ansi"

)


# If those interfering files exist, remove them.
for file in ${_FILES_TO_REMOVE_[@]}; do     # SC2068 - no quotes expand into multiple other arguments
    if [ -f "${file}" ]; then
        rm "${file}"
    fi
done

# Enter the installation directory and execute npm from a subshell,
# keeping our main shell in start directory.
(
    cd "${_install_dir_}"
    # ensure latest npm
    npm install npm@latest
    # install
    node_modules/.bin/npm install node-gyp node-pre-gyp fibers
)


# Before activating any new version of node, first store the current
# symlink path to ~/wekan/current into a variable.
_former_version_="$(ls -la "$HOME"/wekan/current |cut -d'>' -f2)"


# Now we're safe to point that symlink to the bundle directory of our new version.
ln -sfn "${_dir_}/bundle" "$HOME/wekan/current"


# Checking whether wekan service is up & running.
if restart_wekan; then

    # Successful? Let's report ...
    tput smso; echo -e "\n We're done--wekan is up to date, exiting now.\n\n"; tput rmso

else
	# ... if not, roll back to the old node version, undo the symlink
	# change and restart the service.
    tput bel; tput smso; tput setaf 1; echo -e "\n Something went wrong--returning now to the former version.\n\n"; tput rmso; tput sgr0
fi

# That's all, folks.
exit 0
